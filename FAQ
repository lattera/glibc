		Frequently Asked Question on GNU C Library

As every FAQ this one also tries to answer questions the user might have
when using the pacakge.  Please make sure you read this before sending
questions or bug reports to the maintainers.

The GNU C Library is very complex.  The building process exploits the
features available in tools generally available.  But many things can
only be done using GNU tools.  Also the code is sometimes hard to
understand because it has to be portable but on the other hand must be
fast.  But you need not understand the details to use GNU C Library.
This will only be necessary if you intend to contribute or change it.

If you have any questions you think should be answered in this document,
please let me know.

						  --drepper@cygnus.com

~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q1]	``What systems does the GNU C Library run on?''

[Q2]	``What compiler do I need to build GNU libc?''

[Q3]	``When starting make I get only error messages.
	  What's wrong?''

[Q4]	``After I changed configure.in I get `Autoconf version X.Y.
	  or higher is required for this script'.  What can I do?''

[Q5]	``Do I need a special linker or archiver?''

[Q6]	``Do I need some more things to compile GNU C Library?''

[Q7]	``When I run `nm libc.so|grep " U "' on the produced library
	  I still find unresolved symbols?  Can this be ok?''

[Q8]	``I expect GNU libc to be 100% source code compatible with
	  the old Linux based GNU libc.  Why isn't it like this?''


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q1]	``What systems does the GNU C Library run on?''

[A1] {UD} This is difficult to answer.  The file `README' lists the
architectures GNU libc is known to run *at some time*.  This does not
mean that it still can be compiled and run on them in the moment.

The systems glibc is known to work on in the moment and most probably
in the future are:

	*-*-gnu			GNU Hurd
	i[3456]86-*-linux	Linux-2.0 on Intel

Other Linux platforms are also on the way to be supported but I need
some success reports first.

If you have a system not listed above (or in the `README' file) and
you are really interested in porting it, contact

	<bug-glibc@prep.ai.mit.edu>


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q2]	``What compiler do I need to build GNU libc?''

[A2] {UD} It is (almost) impossible to compile GNU C Library using a
different compiler than GNU CC.  A lot of extensions of GNU CC are
used to increase the portability and speed.

But this does not mean you have to use GNU CC for using the GNU C
Library.  In fact you should be able to use the native C compiler
because the success only depends on the binutils: the linker and
archiver.

The GNU CC is found like all other GNU packages on
	ftp://prep.ai.mit.edu/pub/gnu
or better one of the many mirrors.

You always should try to use the latest official release.  Older
versions might not have all the features GNU libc could use.


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q3]	``When starting make I get only errors messages.
	  What's wrong?''

[A3] {UD} You definitely need GNU make to translate GNU libc.  No
other make program has the needed functionality.

Versions before 3.74 have bugs which prevent correct execution so you
should upgrade to the latest version before starting the compilation.


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q4]	``After I changed configure.in I get `Autoconf version X.Y.
	  or higher is required for this script'.  What can I do?''

[A4] {UD} You have to get the specified autoconf version (or a later)
from your favourite mirror of prep.ai.mit.edu.


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q5]	``Do I need a special linker or archiver?''

[A5] {UD} If your native versions are not too buggy you can probably
work with them.  But GNU libc works best with GNU binutils.

On systems where the native linker does not support weak symbols you
will not get a really ISO C compliant C library.  Generally speaking
you should use the GNU binutils if they provide at least the same
functionality as your system's tools.

Always get the newest release of GNU binutils available.
Older releases are known to have bugs that affect building the GNU C library.


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q6]	``Do I need some more things to compile GNU C Library?''

[A6] {UD} Yes, there are some more :-).

* lots of diskspace (for i386-linux this means, e.g., ~70MB).

  You should avoid compiling on a NFS mounted device.  This is very
  slow.

* plenty of time (approx 1h for i386-linux on i586@133 or 2.5h or
  i486@66).

  If you are interested in some more measurements let me know.

* Some files depend on special tools.  E.g., files ending in .gperf
  need a `gperf' program.  The GNU version (part of libg++) is known
  to work while some vendor versions do not.

* When compiling for Linux:

  + the header files of the Linux kernel must be available in the
    search path of the CPP as <linux/*.h> and <asm/*.h>.


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q7]	``When I run `nm libc.so|grep " U "' on the produced library
	  I still find unresolved symbols?  Can this be ok?''

[A7] {UD} Yes, this is ok.  There can be several kinds of unresolved
symbols:

* magic symbols automatically generated by the linker.  Names are
  often like __start_* and __stop_*

* symbols resolved by using libgcc.a
  (__udivdi3, __umoddi3, or similar)

* weak symbols, which need not be resolved at all
  (currently fabs among others; this gets resolved if the program
   is linked against libm, too.)

Generally, you should make sure you find a real program which produces
errors while linking before deciding there is a problem.


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
[Q8]	``I expect GNU libc to be 100% source code compatible with
	  the old Linux based GNU libc.  Why isn't it like this?''

[A8] {DMT} Not every extension in Linux libc's history was well
thought-out.  In fact it had a lot of problems with standards compliance
and with cleanliness.  With the introduction of a new version number these
errors now can be corrected.  Here is a list of the known source code
incompatibilities:

* _GNU_SOURCE: glibc does not automatically define _GNU_SOURCE.  Thus,
  if a program depends on GNU extensions or some other non-standard
  functionality, it is necessary to compile it with C compiler option
  -D_GNU_SOURCE, or better, to put `#define _GNU_SOURCE' at the beginning
  of your source files, before any C library header files are included.
  This difference normally manifests itself in the form of missing
  prototypes and/or data type definitions.  Thus, if you get such errors,
  the first thing you should do is try defining _GNU_SOURCE and see if
  that makes the problem go away.

  For more information consult the file `NOTES' part of the GNU C
  library sources.

* reboot(): GNU libc sanitizes the interface of reboot() to be more
  compatible with the interface used on other OSes.  In particular,
  reboot() as implemented in glibc takes just one argument.  This argument
  corresponds to the third argument of the Linux reboot system call.
  That is, a call of the form reboot(a, b, c) needs to be changed into
  reboot(c).

* errno: If a program uses variable "errno", then it _must_ include header
  file <errno.h>.  The old libc often (erroneously) declared this variable
  implicitly as a side-effect of including other libc header files.  glibc
  is careful to avoid such namespace pollution, which, in turn, means that
  you really need to include the header files that you depend on.  This
  difference normally manifests itself in the form of the compiler
  complaining about the references of the undeclared symbol "errno".

* Linux-specific syscalls: All Linux system calls now have appropriate
  library wrappers and corresponding declarations in various header files.
  This is because the syscall() macro that was traditionally used to
  work around missing syscall wrappers are inherently non-portable and
  error-prone.  The following tables lists all the new syscall stubs,
  the header-file declaring their interface and the system call name.

       syscall name:	wrapper name:	declaring header file:
       -------------	-------------	----------------------
       bdflush		bdflush		<sys/kdaemon.h>
       create_module	create_module	<sys/module.h>
       delete_module	delete_module	<sys/module.h>
       get_kernel_syms	get_kernel_syms	<sys/module.h>
       init_module	init_module	<sys/module.h>
       syslog		ksyslog_ctl	<sys/klog.h>

~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~


Answers were given by:
{UD} Ulrich Drepper, <drepper@cygnus.com>
{DMT} David Mosberger-Tang, <davidm@AZStarNet.com>

Amended by:
{RM} Roland McGrath, <roland@gnu.ai.mit.edu>

Local Variables:
 mode:text
End:
